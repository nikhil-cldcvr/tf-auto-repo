pipeline {
    agent {
        label 'win'
    }

    parameters {
        string(name: 'BRANCH', defaultValue: 'main', description: 'The branch name to analyze')
        string(name: 'PROJECT_KEYS', defaultValue: 'first_prj', description: 'Comma-separated SonarQube project keys')
    }

    environment {
        SONAR_URL = "http://34.93.20.19:9000" // Change to your SonarQube URL
        API_TOKEN = "squ_6d1c8e1bc790e15e361209548d6d0de0ad2ca8a5"  // Replace with your API token
    }

    stages {
        stage('Fetch Overall SonarQube Metrics') {
            steps {
                script {
                    def projectKeys = params.PROJECT_KEYS.split(',')
                    def csvReport = new StringBuilder()
                    csvReport.append("Project Name,Branch,Code Smells - Major,Code Smells - Critical,Code Smells - Minor,Code Smells - Blocker,Vulnerabilities - Major,Vulnerabilities - Critical,Vulnerabilities - Minor,Vulnerabilities - Blocker,Bugs - Major,Bugs - Critical,Bugs - Minor,Bugs - Blocker,Lines of Code,Violations,Blocker Violations,Number of Files,Complexity,Quality Gate Status,Number of Classes\n")

                    def metricQuery = "ncloc,violations,blocker_violations,files,complexity,classes"
                    def issueTypes = ['major', 'critical', 'minor', 'blocker']
                    def issueCategories = ['CODE_SMELL', 'VULNERABILITY', 'BUG']

                    projectKeys.each { projectKey ->
                        projectKey = projectKey.trim()

                        // Fetch project quality gate status
                        bat(script: """
                            curl -s -u ${env.API_TOKEN}: ${env.SONAR_URL}/api/qualitygates/project_status?projectKey=${projectKey} -o quality_gate_status_${projectKey}.json
                        """)

                        // Fetch various metrics
                        bat(script: """
                            curl -s -u ${env.API_TOKEN}: "${env.SONAR_URL}/api/measures/component?component=${projectKey}&metricKeys=${metricQuery}" -o sonar_metrics_${projectKey}.json
                        """)

                        // Read and parse the JSON files
                        def qualityGateJson = readJSON file: "quality_gate_status_${projectKey}.json"
                        def metricsJson = readJSON file: "sonar_metrics_${projectKey}.json"

                        def qualityGate = qualityGateJson.projectStatus.status

                        // Extract metric values
                        def metricsMap = metricsJson.component.measures.collectEntries { [(it.metric): it.value] }

                        // Initialize issue counts with explicit default values
                        def issueCounts = ['CODE_SMELL_major': 0, 'CODE_SMELL_critical': 0, 'CODE_SMELL_minor': 0, 'CODE_SMELL_blocker': 0,
                                           'VULNERABILITY_major': 0, 'VULNERABILITY_critical': 0, 'VULNERABILITY_minor': 0, 'VULNERABILITY_blocker': 0,
                                           'BUG_major': 0, 'BUG_critical': 0, 'BUG_minor': 0, 'BUG_blocker': 0]

                        // Fetch detailed issues count for each severity type and category
                        issueCategories.each { category ->
                            issueTypes.each { severity ->
                                bat(script: """
                                    curl -s -u ${env.API_TOKEN}: "${env.SONAR_URL}/api/issues/search?componentKeys=${projectKey}&types=${category}&severities=${severity.toUpperCase()}&statuses=OPEN" -o issues_${projectKey}_${category}_${severity}.json
                                """)
                                def issuesJson = readJSON file: "issues_${projectKey}_${category}_${severity}.json"
                                issueCounts["${category}_${severity}"] = issuesJson.total ?: 0
                            }
                        }

                        // Append data to the CSV report
                        csvReport.append("${projectKey},${params.BRANCH},")
                        csvReport.append("${issueCounts['CODE_SMELL_major']},${issueCounts['CODE_SMELL_critical']},${issueCounts['CODE_SMELL_minor']},${issueCounts['CODE_SMELL_blocker']},")
                        csvReport.append("${issueCounts['VULNERABILITY_major']},${issueCounts['VULNERABILITY_critical']},${issueCounts['VULNERABILITY_minor']},${issueCounts['VULNERABILITY_blocker']},")
                        csvReport.append("${issueCounts['BUG_major']},${issueCounts['BUG_critical']},${issueCounts['BUG_minor']},${issueCounts['BUG_blocker']},")
                        csvReport.append("${metricsMap['ncloc'] ?: '0'},${metricsMap['violations'] ?: '0'},${metricsMap['blocker_violations'] ?: '0'},${metricsMap['files'] ?: '0'},${metricsMap['complexity'] ?: '0'},${qualityGate ?: 'N/A'},${metricsMap['classes'] ?: '0'}\n")
                    }

                    // Save and archive the CSV report
                    writeFile file: 'sonar_detailed_metrics_report.csv', text: csvReport.toString()
                    archiveArtifacts artifacts: 'sonar_detailed_metrics_report.csv'
                }
            }
        }

        stage('Fetch New Code Metrics') {
          steps {
                script {
                    def projectKeys = params.PROJECT_KEYS.split(',')
                    def csvReport = new StringBuilder()
                    csvReport.append("Project Name,Branch,Code Smells - Major,Code Smells - Critical,Code Smells - Minor,Code Smells - Blocker,Vulnerabilities - Major,Vulnerabilities - Critical,Vulnerabilities - Minor,Vulnerabilities - Blocker,Bugs - Major,Bugs - Critical,Bugs - Minor,Bugs - Blocker,Lines of Code,Violations,Blocker Violations,Number of Files,Complexity,Quality Gate Status,Number of Classes\n")

                    def metricQuery = "ncloc,violations,blocker_violations,files,complexity,classes"
                    def issueTypes = ['major', 'critical', 'minor', 'blocker']
                    def issueCategories = ['CODE_SMELL', 'VULNERABILITY', 'BUG']

                    projectKeys.each { projectKey ->
                        projectKey = projectKey.trim()

                        // Fetch project quality gate status
                        bat(script: """
                            curl -s -u ${env.API_TOKEN}: "${env.SONAR_URL}/api/qualitygates/project_status?projectKey=${projectKey}&inNewCodePeriod=true" -o quality_gate_status_${projectKey}.json
                        """)

                        // Fetch various metrics
                        bat(script: """
                            curl -s -u ${env.API_TOKEN}: "${env.SONAR_URL}/api/measures/component?component=${projectKey}&metricKeys=${metricQuery}&inNewCodePeriod=true" -o sonar_metrics_${projectKey}.json
                        """)

                        // Read and parse the JSON files
                        def qualityGateJson = readJSON file: "quality_gate_status_${projectKey}.json"
                        def metricsJson = readJSON file: "sonar_metrics_${projectKey}.json"

                        def qualityGate = qualityGateJson.projectStatus.status

                        // Extract metric values
                        def metricsMap = metricsJson.component.measures.collectEntries { [(it.metric): it.value] }

                        // Initialize issue counts with explicit default values
                        def issueCounts = ['CODE_SMELL_major': 0, 'CODE_SMELL_critical': 0, 'CODE_SMELL_minor': 0, 'CODE_SMELL_blocker': 0,
                                           'VULNERABILITY_major': 0, 'VULNERABILITY_critical': 0, 'VULNERABILITY_minor': 0, 'VULNERABILITY_blocker': 0,
                                           'BUG_major': 0, 'BUG_critical': 0, 'BUG_minor': 0, 'BUG_blocker': 0]

                        // Fetch detailed issues count for each severity type and category
                        issueCategories.each { category ->
                            issueTypes.each { severity ->
                                bat(script: """
                                    curl -s -u ${env.API_TOKEN}: "${env.SONAR_URL}/api/issues/search?componentKeys=${projectKey}&types=${category}&severities=${severity.toUpperCase()}&statuses=OPEN&inNewCodePeriod=true" -o issues_${projectKey}_${category}_${severity}.json
                                """)
                                def issuesJson = readJSON file: "issues_${projectKey}_${category}_${severity}.json"
                                issueCounts["${category}_${severity}"] = issuesJson.total ?: 0
                            }
                        }

                        // Append data to the CSV report
                        csvReport.append("${projectKey},${params.BRANCH},")
                        csvReport.append("${issueCounts['CODE_SMELL_major']},${issueCounts['CODE_SMELL_critical']},${issueCounts['CODE_SMELL_minor']},${issueCounts['CODE_SMELL_blocker']},")
                        csvReport.append("${issueCounts['VULNERABILITY_major']},${issueCounts['VULNERABILITY_critical']},${issueCounts['VULNERABILITY_minor']},${issueCounts['VULNERABILITY_blocker']},")
                        csvReport.append("${issueCounts['BUG_major']},${issueCounts['BUG_critical']},${issueCounts['BUG_minor']},${issueCounts['BUG_blocker']},")
                        csvReport.append("${metricsMap['ncloc'] ?: '0'},${metricsMap['violations'] ?: '0'},${metricsMap['blocker_violations'] ?: '0'},${metricsMap['files'] ?: '0'},${metricsMap['complexity'] ?: '0'},${qualityGate ?: 'N/A'},${metricsMap['classes'] ?: '0'}\n")
                    }

                    // Save and archive the CSV report
                    writeFile file: 'sonar_new_code_metrics_report.csv', text: csvReport.toString()
                    archiveArtifacts artifacts: 'sonar_new_code_metrics_report.csv'
                }
            }
        }
    }

    post {
        always {
            echo 'Cleaning up...'
            deleteDir()
        }
    }
}
