pipeline {
    agent {
        label 'win'
    }

    parameters {
        string(name: 'INPUTS', defaultValue: 'jenkins-project:main', description: 'Comma-separated list of project inputs in the format PROJECT_KEYS:BRANCH')
    }

    environment {
        SONAR_URL = "http://34.100.224.130:9000" // Change to your SonarQube URL
        API_TOKEN = "squ_9aa34b2df5bb53ea7a6775655f430bf3c0810bb1"  // Replace with your API token
    }

    stages {
        stage('Fetch SonarQube Metrics') {
            steps {
                script {
                    def csvReport = new StringBuilder()
                    csvReport.append("Overall Code Report,,,,,,,,,,,,,,,,,,,,,,,,,,\n")
                    csvReport.append(",Categories,,,Code Smells,,,,,,,,Vulnerabilities,,,,,,,,Bugs,,,,,,,\n")
                    csvReport.append(",Project Name,Branch,Rule Name,Major,Rule Name,Critical,Rule Name,Minor,Rule Name,Blocker,Rule Name,Major,Rule Name,Critical,Rule Name,Minor,Rule Name,Blocker,Rule Name,Major,Rule Name,Critical,Rule Name,Minor,Rule Name,Blocker\n")

                    def issueTypes = ['major', 'critical', 'minor', 'blocker']
                    def issueCategories = ['CODE_SMELL', 'VULNERABILITY', 'BUG']
                    def projectInputs = params.INPUTS.split(',')
                    def ruleCounts = [:] // Initialize the map to store rule counts by category and severity

                    projectInputs.each { input ->
                        def parts = input.split(':')
                        def projectKey = parts[0].trim()
                        def branch = parts[1].trim()

                        // Populate ruleCounts from the API results
                        issueCategories.each { category ->
                            issueTypes.each { severity ->
                                def key = "${category}_${severity}".toUpperCase() // Create key for category_severity

                                // Execute the curl command to fetch issues
                                bat(script: """
                                    curl -s -u ${env.API_TOKEN}: "${env.SONAR_URL}/api/issues/search?componentKeys=${projectKey}&branch=${branch}&types=${category}&severities=${severity.toUpperCase()}&ps=500" -o issues_${projectKey}_${category}_${severity}.json
                                """)

                                // Read the JSON response
                                def issuesJson = readJSON file: "issues_${projectKey}_${category}_${severity}.json"

                                // Initialize the rule count map for this key if it doesn't exist
                                if (!ruleCounts.containsKey(key)) {
                                    ruleCounts[key] = [:]
                                }

                                // Count occurrences of each rule for this category and severity
                                issuesJson.issues.each { issue ->
                                    def rule = issue.rule
                                    if (ruleCounts[key].containsKey(rule)) {
                                        ruleCounts[key][rule] += 1 // Increment count if rule already exists
                                    } else {
                                        ruleCounts[key][rule] = 1 // Initialize count if rule is new
                                    }
                                }
                            }
                        }

                        // For each project, write the counts into the CSV format
                        issueCategories.each { category ->
                            issueTypes.each { severity ->
                                def key = "${category}_${severity}".toUpperCase() // Create key for category_severity

                                // Now loop through the ruleCounts for this specific category and severity
                                if (ruleCounts.containsKey(key)) {
                                    ruleCounts[key].each { rule, count ->
                                        def row = new StringBuilder()
                                        row.append(",${projectKey},${branch},${rule},") // Add project, branch, and rule

                                        // Populate the CSV for each category and severity
                                        issueCategories.each { innerCategory ->
                                            issueTypes.each { innerSeverity ->
                                                def innerKey = "${innerCategory}_${innerSeverity}".toUpperCase()

                                                // Check if the rule exists for the current category and severity
                                                if (ruleCounts[innerKey]?.containsKey(rule)) {
                                                    row.append("${ruleCounts[innerKey][rule]},") // Append count
                                                } else {
                                                    row.append("N/A,0,") // If rule not present, append N/A and 0
                                                }
                                            }
                                        }

                                        // Append the row to the CSV report
                                        csvReport.append(row.toString().replaceAll(/,$/, "\n")) // Remove trailing comma and append newline
                                    }
                                }
                            }
                        }
                    }

                    // Optionally, print the CSV report to console
                    // Write CSV report to a file
                    writeFile file: 'SonarQube_Metrics_Report.csv', text: csvReport.toString()
                    archiveArtifacts artifacts: 'SonarQube_Metrics_Report.csv'
                }
            }
        }
    }
}
