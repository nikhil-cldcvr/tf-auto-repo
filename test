pipeline {
    agent {
        label 'win'
    }

    parameters {
        string(name: 'INPUTS', defaultValue: 'jenkins-project:main', description: 'Comma-separated list of project inputs in the format PROJECT_KEYS:BRANCH')
    }

    environment {
        SONAR_URL = "http://34.93.143.240:9000" // Change to your SonarQube URL
        API_TOKEN = "squ_9aa34b2df5bb53ea7a6775655f430bf3c0810bb1"  // Replace with your API token
    }

    stages {
        stage('Fetch SonarQube Metrics') {
            steps {
                script {
                    def csvReport = new StringBuilder()
                    csvReport.append("Overall Code Report,,,,,,,,,,,,,,,,,,,,,,,,,,\n")
                    csvReport.append(",Categories,,,Code Smells,,,,,,,,Vulnerabilities,,,,,,,,Bugs,,,,,,,\n")
                    csvReport.append(",Project Name,Branch,Rule Name,Major,Rule Name,Critical,Rule Name,Minor,Rule Name,Blocker,Rule Name,Major,Rule Name,Critical,Rule Name,Minor,Rule Name,Blocker,Rule Name,Major,Rule Name,Critical,Rule Name,Minor,Rule Name,Blocker\n")

                    def projectInputs = params.INPUTS.split(',')
                    def ruleCounts = [:] // Initialize the map to store rule counts by category and severity

                    projectInputs.each { input ->
                        def parts = input.split(':')
                        def projectKey = parts[0].trim()
                        def branch = parts[1].trim()

                        def page = 1
                        def totalIssues = 0
                        def isLastPage = false

                        // Pagination loop to handle more than 15,000 issues
                        while (!isLastPage) {
                            bat(script: """
                                curl -s -u ${env.API_TOKEN}: "${env.SONAR_URL}/api/issues/search?componentKeys=${projectKey}&branch=${branch}&ps=500&p=${page}" -o issues_${projectKey}_${page}.json
                            """)

                            // Read the JSON response
                            def issuesJson = readJSON file: "issues_${projectKey}_${page}.json"
                            // Handle pagination
                            totalIssues += issuesJson.issues.size()
                            isLastPage = issuesJson.paging.total <= totalIssues
                            page++

                            // Count occurrences of each rule across all categories and severities
                            issuesJson.issues.each { issue ->
                                def rule = issue.rule
                                def category = issue.type // CODE_SMELL, VULNERABILITY, BUG
                                def severity = issue.severity.toLowerCase() // major, critical, minor, blocker
                                def key = "${category}_${severity}".toUpperCase()

                                // Initialize the rule count map for this key
                                if (!ruleCounts.containsKey(key)) {
                                    ruleCounts[key] = [:]
                                }

                                // Count occurrences of each rule for this category and severity
                                if (ruleCounts[key].containsKey(rule)) {
                                    ruleCounts[key][rule] += 1 // Increment count if rule already exists
                                } else {
                                    ruleCounts[key][rule] = 1 // Initialize count if rule is new
                                }
                            }
                        }
                        println ruleCounts
                        // For each project, write the counts into the CSV format
                        ruleCounts.each { categorySeverity, rules ->
                            rules.each { rule, count ->
                                def row = new StringBuilder()
                                row.append(",${projectKey},${branch},")

                                // Add the rule name and counts in the appropriate places
                                ['CODE_SMELL', 'VULNERABILITY', 'BUG'].each { category ->
                                    ['major', 'critical', 'minor', 'blocker'].each { severity ->
                                        def key = "${category}_${severity}".toUpperCase()
                                        def ruleEntry = ruleCounts[key]?.find { it.key == rule }
                                        if (ruleEntry) {
                                            row.append("${ruleEntry.key},${ruleEntry.value},")
                                        } else {
                                            row.append("N/A,0,")
                                        }
                                    }
                                }

                                // Append the row to the CSV report
                                csvReport.append(row.toString().replaceAll(/,$/, "\n")) // Remove trailing comma
                            }
                        }
                    }

                    // Optionally, print the CSV report to the console
                    // Write CSV report to a file
                    writeFile file: 'SonarQube_Metrics_Report.csv', text: csvReport.toString()
                    archiveArtifacts artifacts: 'SonarQube_Metrics_Report.csv'
                }
            }
        }
    }
}
