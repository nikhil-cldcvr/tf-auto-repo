pipeline {
    agent {
        label 'win'
    }

    parameters {
        string(name: 'INPUTS', defaultValue: 'jenkins-project:main', description: 'Comma-separated list of project inputs in the format PROJECT_KEYS:BRANCH')
    }

    environment {
        SONAR_URL = "http://35.244.7.10:9000" // Change to your SonarQube URL
        API_TOKEN = "squ_9aa34b2df5bb53ea7a6775655f430bf3c0810bb1"  // Replace with your API token
    }

    stages {
        stage('Fetch SonarQube Metrics') {
            steps {
                script {
                    def csvReport = new StringBuilder()
                    csvReport.append("Overall Code Report,,,,,,,,,,,,,,,,,,,,,,,,,,\n")
                    csvReport.append(",Categories,,,,,,,,,,,,,,,,,,,Bugs,,,,,,,\n")
                    csvReport.append(",Project Name,Branch,Rule Name,Count,Category,,,,,,,,,,Rule Name,Minor,Rule Name,Blocker,Rule Name,Major,Rule Name,Critical,Rule Name,Minor,Rule Name,Blocker\n")

                    def projectInputs = params.INPUTS.split(',')
                    def severities = ['BLOCKER', 'CRITICAL', 'MAJOR', 'MINOR']

                    projectInputs.each { input ->
                        def parts = input.split(':')
                        def projectKey = parts[0].trim()
                        def branch = parts[1].trim()
                        def ruleCounts = [:] // Initialize rule counts for this project

                        // Fetch issues without pagination
                        def issuesJson = [:]
                        severities.each { severity ->
                            bat(script: """
                                curl -s -u ${env.API_TOKEN}: "${env.SONAR_URL}/api/issues/search?componentKeys=${projectKey}&branch=${branch}&statuses=OPEN&severities=${severity}&ps=500" -o issues_${projectKey}_${severity}.json
                            """)

                            // Read the JSON response
                            issuesJson = readJSON file: "issues_${projectKey}_${severity}.json"

                            // Check if there are any issues returned
                            if (issuesJson.total == 0) {
                                echo "No issues found for ${projectKey} with severity ${severity}."
                                return
                            }

                            // Process the issues to count rules by category and severity
                            issuesJson.issues.each { issue ->
                                def rule = issue.rule
                                def severityType = issue.severity.toLowerCase()
                                def category = issue.type.toUpperCase()

                                // Construct the key for counting
                                def key = "${category}_${severityType}".toUpperCase()

                                // Initialize the count map for this key
                                if (!ruleCounts.containsKey(key)) {
                                    ruleCounts[key] = [:]
                                }

                                // Increment the rule count
                                if (ruleCounts[key].containsKey(rule)) {
                                    ruleCounts[key][rule] += 1 // Increment if rule already exists
                                } else {
                                    ruleCounts[key][rule] = 1 // Initialize if rule is new
                                }
                            }
                        }

                        // For each project, write the counts into the CSV format
                        ruleCounts.each { categorySeverity, rules ->
                            rules.each { rule, count ->
                                def row = new StringBuilder()
                                row.append(",${projectKey},${branch},")
                                
                                // Determine the category based on the severity
                                def category = ''
                                if (categorySeverity.contains('CODE_SMELL')) {
                                    category = "CodeSmell-${categorySeverity.split('_')[2].capitalize()}"
                                } else if (categorySeverity.contains('VULNERABILITY')) {
                                    category = "Vulnerability-${categorySeverity.split('_')[1].capitalize()}"
                                } else if (categorySeverity.contains('BUG')) {
                                    category = "Bug-${categorySeverity.split('_')[1].capitalize()}"
                                }
                                row.append("${rule},${count},${category},") // Add rule, count, and category

                                // Add placeholders for other counts
                                row.append(",,,,,,,,,,,,,,,,,,,,,,") // Adjust as necessary for other categories
                                
                                // Append the row to the CSV report
                                csvReport.append(row.toString().replaceAll(/,$/, "\n")) // Remove trailing comma
                            }
                        }
                    }

                    // Write final CSV report to a file
                    writeFile file: 'SonarQube_Metrics_Report.csv', text: csvReport.toString()
                    archiveArtifacts artifacts: 'SonarQube_Metrics_Report.csv'
                }
            }
        }
    }
}
