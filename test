pipeline {
    agent {
        label 'win'
    }

    parameters {
        string(name: 'INPUTS', defaultValue: 'jenkins-project:main', description: 'Comma-separated list of project inputs in the format PROJECT_KEYS:BRANCH')
    }

    environment {
        SONAR_URL = "http://35.244.7.10:9000" // Change to your SonarQube URL
        // It's recommended to store API_TOKEN in Jenkins credentials
    }

    stages {
        stage('Fetch SonarQube Metrics') {
            steps {
                script {
                    def csvReport = new StringBuilder()
                    csvReport.append("Overall Code Report,,,,,,,,,,,,,,,,,,,,,,,,,,\n")
                    csvReport.append(",Categories,,,,,,,,,,,,,,,,,,,Bugs,,,,,,,\n")
                    csvReport.append(",Project Name,Branch,Rule Name,Count,Category,,,,,,,,,,Rule Name,Minor,Rule Name,Blocker,Rule Name,Major,Rule Name,Critical,Rule Name,Minor,Rule Name,Blocker\n")

                    def projectInputs = params.INPUTS.split(',')

                    projectInputs.each { input ->
                        def parts = input.split(':')
                        def projectKey = parts[0].trim()
                        def branch = parts[1].trim()
                        def ruleCounts = [:] // Initialize rule counts for this project

                        int page = 1
                        int pageSize = 500
                        int totalIssues = 0

                        // Paginate over SonarQube issues
                        while (true) {
                            bat(script: """
                                curl -s -u ${env.API_TOKEN}: "${env.SONAR_URL}/api/issues/search?componentKeys=${projectKey}&branch=${branch}&ps=${pageSize}&p=${page}" -o issues_${projectKey}_page_${page}.json
                            """)

                            def issuesJson = readJSON file: "issues_${projectKey}_page_${page}.json"

                            // Check if there are any issues returned
                            if (issuesJson.total == 0) {
                                echo "No issues found for project: ${projectKey}, branch: ${branch}"
                                break
                            }

                            // Process the issues to count rules by category and severity
                            issuesJson.issues.each { issue ->
                                def rule = issue.rule
                                def severity = issue.severity.toLowerCase()
                                def category = issue.type.toUpperCase()

                                // Construct the key for counting
                                def key = "${category}_${severity}".toUpperCase()

                                // Initialize the count map for this key
                                if (!ruleCounts.containsKey(key)) {
                                    ruleCounts[key] = [:]
                                }

                                // Increment the rule count
                                if (ruleCounts[key].containsKey(rule)) {
                                    ruleCounts[key][rule] += 1
                                } else {
                                    ruleCounts[key][rule] = 1
                                }

                                echo "Rule: ${rule}, Category: ${category}, Severity: ${severity}, Count: ${ruleCounts[key][rule]}"
                            }

                            // Check if we've retrieved the last page
                            totalIssues = issuesJson.total
                            if (page * pageSize >= totalIssues) {
                                break // Exit loop if all issues are processed
                            }

                            page++ // Increment page for next API call
                        }

                        // Write rule counts for each project and branch into the CSV report
                        ruleCounts.each { categorySeverity, rules ->
                            rules.each { rule, count ->
                                def row = new StringBuilder()
                                row.append(",${projectKey},${branch},")
                                
                                // Determine the category based on severity
                                def category = ''
                                if (categorySeverity.contains('CODE_SMELL')) {
                                    category = "CodeSmell-${categorySeverity.split('_')[2].capitalize()}"
                                } else if (categorySeverity.contains('VULNERABILITY')) {
                                    category = "Vulnerability-${categorySeverity.split('_')[1].capitalize()}"
                                } else if (categorySeverity.contains('BUG')) {
                                    category = "Bug-${categorySeverity.split('_')[1].capitalize()}"
                                }
                                row.append("${rule},${count},${category},") // Add rule, count, and category

                                // Add placeholders for other counts
                                row.append(",,,,,,,,,,,,,,,,,,,,,,") // Adjust for other categories

                                // Append the row to the CSV report
                                csvReport.append(row.toString().replaceAll(/,$/, "\n")) // Remove trailing comma
                            }
                        }
                    }

                    // Write the final CSV report to a file and archive it
                    writeFile file: 'SonarQube_Metrics_Report.csv', text: csvReport.toString()
                    archiveArtifacts artifacts: 'SonarQube_Metrics_Report.csv'
                }
            }
        }
    }
}
