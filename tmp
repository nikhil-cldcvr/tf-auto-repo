pipeline {
    agent {
        label 'win'  // Adjust to your Jenkins agent label
    }

    parameters {
        string(name: 'INPUTS', defaultValue: 'jenkins-project:main,dev,feature:2024-01-01;first_prj:main,feature,release:2024-01-01;', description: 'Semicolon-separated list of project inputs in the format PROJECT_NAME:BRANCH1,BRANCH2,...:DATE; (DATE is optional)')
    }

    environment {
        SONAR_URL = "http://34.93.27.191:9000"  // Update to your SonarQube URL
        API_TOKEN = "squ_9aa34b2df5bb53ea7a6775655f430bf3c0810bb1"  // Replace with your actual API token stored in Jenkins
    }

    stages {
        stage('Fetch SonarQube Metrics') {
            steps {
                script {
                    def projectInputs = params.INPUTS.split(';')
                    def csvReport = new StringBuilder()

                    def issueCategories = ['CODE_SMELL', 'VULNERABILITY', 'BUG']
                    def branchGroups = [:]

                    projectInputs.each { input ->
                        if (input.trim()) {
                            def parts = input.split(':')
                            def projectKey = parts[0].trim()
                            def branches = parts[1].trim().split(',')
                            def date = parts.size() > 2 ? parts[2].trim() : null

                            branches.each { branch ->
                                if (!branchGroups.containsKey(branch)) {
                                    branchGroups[branch] = []
                                }
                                branchGroups[branch] << [projectKey: projectKey, date: date]
                            }
                        }
                    }

                    branchGroups.each { branch, projects ->
                        // Add section header for each branch
                        csvReport.append("${branch} Report,,,,,,,,,,,,,,,,,,,\n")
                        csvReport.append(",Categories,,,Code Smells,,,,Vulnerabilities,,,,Bugs,,,,,,Total Count,\n")
                        csvReport.append(",From,Project Name,Branch,Major,Critical,Minor,Blocker,Major,Critical,Minor,Blocker,Major,Critical,Minor,Blocker,,Code Smells,Vulnerabilities,Bugs\n")


                        projects.each { project ->
                            def projectKey = project.projectKey
                            def date = project.date
                            csvReport.append(",${date ?: 'N/A'},${projectKey},${branch},")

                            def totalCounts = [ 'CODE_SMELL': 0, 'VULNERABILITY': 0, 'BUG': 0 ]

                            issueCategories.each { category ->
                                def page = 1
                                def totalIssues = 0
                                def isLastPage = false
                                def severityMap = [
                                    'major': 0,
                                    'critical': 0,
                                    'minor': 0,
                                    'blocker': 0
                                ]

                                while (!isLastPage) {
                                    def issuesUrl = "${env.SONAR_URL}/api/issues/search?componentKeys=${projectKey}&branch=${branch}&types=${category}&severities=BLOCKER,CRITICAL,MAJOR,MINOR&statuses=OPEN&ps=500&p=${page}"
                                    if (date) {
                                        issuesUrl += "&createdAfter=${date}"
                                    }

                                    bat(script: """
                                        curl -s -u ${env.API_TOKEN}: "${issuesUrl}" -o issues_${projectKey}_${branch}_${category}_${page}.json
                                    """)
                                    
                                    def issuesJson = readJSON file: "issues_${projectKey}_${branch}_${category}_${page}.json"
                                    totalIssues += issuesJson.issues.size()
                                    isLastPage = issuesJson.issues.isEmpty() || totalIssues >= 1000000 || issuesJson.paging.total <= totalIssues
                                    page++

                                    issuesJson.issues.each { issue ->
                                        def severity = issue.severity.toLowerCase()
                                        if (severityMap.containsKey(severity)) {
                                            severityMap[severity] += 1
                                        }
                                    }
                                }

                                totalCounts[category] = severityMap.values().sum()
                                csvReport.append("${severityMap['major']},${severityMap['critical']},${severityMap['minor']},${severityMap['blocker']},")
                            }

                            csvReport.append(",${totalCounts['CODE_SMELL']},${totalCounts['VULNERABILITY']},${totalCounts['BUG']}\n")
                        }
                        csvReport.append(",,,,,,,,,,,,,,,,,,,\n")
                    }

                    writeFile file: 'SonarQube_Metrics_Report.csv', text: csvReport.toString()
                    archiveArtifacts artifacts: 'SonarQube_Metrics_Report.csv'
                }
            }
        }
    }
}
