pipeline {
    agent {
        label 'win'
    }

    parameters {
        string(name: 'INPUTS', defaultValue: 'jenkins-project:main:2000-01-01,first_prj:main', description: 'Comma-separated list of project inputs in the format PROJECT_KEYS:BRANCH:DATE (DATE is optional)')
    }

    environment {
        SONAR_URL = "http://34.93.167.83:9000" // Change to your SonarQube URL
        API_TOKEN = "squ_9aa34b2df5bb53ea7a6775655f430bf3c0810bb1" // Replace with your API token
    }

    stages {
        stage('Fetch SonarQube Metrics') {
            steps {
                script {
                    def projectInputs = params.INPUTS.split(',')

                    def csvReport = new StringBuilder()
                    csvReport.append("Issues Report,\n")
                    csvReport.append(",,,,Code Smells,,,,Vulnerabilities,,,,Bugs,,,,\n")
                    csvReport.append(",From,Project Name,Branch,Major,Critical,Minor,Blocker,Major,Critical,Minor,Blocker,Major,Critical,Minor,Blocker,Lines of Code,Violations,Blocker Violations,Number of Files,Complexity,Number of Classes,\n")

                    def metricQuery = "ncloc,violations,blocker_violations,files,complexity,classes"
                    def issueCategories = ['CODE_SMELL', 'VULNERABILITY', 'BUG']

                    projectInputs.each { input ->
                        def parts = input.split(':')
                        def projectKey = parts[0].trim()
                        def branch = parts[1].trim()
                        def date = parts.size() > 2 ? parts[2].trim() : null
                        
                        // Append projectKey and branch to the CSV report
                        csvReport.append(",${date ?: 'N/A'},${projectKey},${branch},")

                        // Fetch various metrics (date is NOT used here)
                        def metricsUrl = "${env.SONAR_URL}/api/measures/component?component=${projectKey}&branch=${branch}&metricKeys=${metricQuery}"
                        if (date) {
                                metricsUrl += "&since=${date}"
                        }
                        bat(script: """
                            curl -s -u ${env.API_TOKEN}: "${metricsUrl}" -o sonar_metrics_${projectKey}.json
                        """)
                        def metricsJson = readJSON file: "sonar_metrics_${projectKey}.json"

                        def metricsMap = [:] // Plain map for metrics
                        metricsJson.component.measures.each { measure ->
                            metricsMap[measure.metric] = measure.value
                        }

                        def issueCounts = [:] // Plain map for issue counts
                        issueCategories.each { category ->
                            // Build the issues API URL, adding createdAfter only if date is provided
                            def issuesUrl = "${env.SONAR_URL}/api/issues/search?componentKeys=${projectKey}&branch=${branch}&types=${category}&severities=BLOCKER,CRITICAL,MAJOR,MINOR&statuses=OPEN"
                            if (date) {
                                issuesUrl += "&createdAfter=${date}"
                            }

                            // API call to fetch all severities in one go for each category
                            bat(script: """
                                curl -s -u ${env.API_TOKEN}: "${issuesUrl}" -o issues_${projectKey}_${category}.json
                            """)
                            def issuesJson = readJSON file: "issues_${projectKey}_${category}.json"

                            // Initialize counts for each severity type
                            def severityMap = [
                                'major': 0,
                                'critical': 0,
                                'minor': 0,
                                'blocker': 0
                            ]

                            // Loop through all issues and count by severity
                            issuesJson.issues.each { issue ->
                                def severity = issue.severity.toLowerCase()
                                if (severityMap.containsKey(severity)) {
                                    severityMap[severity] += 1
                                }
                            }

                            // Append issue counts based on category (Code Smells, Vulnerabilities, Bugs)
                            switch (category) {
                                case 'CODE_SMELL':
                                    csvReport.append("${severityMap['major']},${severityMap['critical']},${severityMap['minor']},${severityMap['blocker']},")
                                    break
                                case 'VULNERABILITY':
                                    csvReport.append("${severityMap['major']},${severityMap['critical']},${severityMap['minor']},${severityMap['blocker']},")
                                    break
                                case 'BUG':
                                    csvReport.append("${severityMap['major']},${severityMap['critical']},${severityMap['minor']},${severityMap['blocker']},")
                                    break
                            }
                        }

                        // Append overall data to the CSV report for metrics
                        csvReport.append("${metricsMap['ncloc'] ?: '0'},${metricsMap['violations'] ?: '0'},${metricsMap['blocker_violations'] ?: '0'},${metricsMap['files'] ?: '0'},${metricsMap['complexity'] ?: '0'},${metricsMap['classes'] ?: '0'},\n")
                    }

                    // Write CSV report to a file
                    writeFile file: 'SonarQube_Metrics_Report.csv', text: csvReport.toString()
                    archiveArtifacts artifacts: 'SonarQube_Metrics_Report.csv'
                }
            }
        }
    }
}
